
一、Mysql的性能调优
	1.参数的设置：数据库参数配置，操作系统的参数配置，硬件参数的配置
	2.SQl语句的调优：索引的添加，optimizer_switch
	3.SSD替换HDD
	4.分布式数据库：引入中间件
		优点：可用性提高，可扩展性提升，某些情况下的吞吐率显著
		缺点：依赖中间件，SQL语句支持不足，运维度复杂，某些情况性能下降
二、分库分表mycat的学习
1、mycat的15种分片方式
	枚举分片：通过在配置文件中配置可能的枚举Id，自己的配置分片
	固定分片Hash算法：类似于十进制的求模运算，在连续的插入1-10时，增大了插入的控制难度
	待续。。。。。。。。。
2、配置文件中的使用密文
conf/servier.xml是Mycat服务器参数调整和用户授权的配置文件，其中配置用户连接的逻辑库、用户名与密码	
3、性能调优
conf/wrapper.conf默认最大堆内存为64M，在大数据迁移很容易出现OutOfMemory，所以调整最大为4G，初始为1G，
wrapper.java.initmemory=1024;wrapper.java.maxmemory=4096
4、查询sql返回数量需要默认值sqlMaxLimit
在《Mycat权威指南》中明确指出，在使用过程中，建议还是增加一个limit，用于减少过多的数据返回。假如要执行select * from TESTDB.travelrecord where id = '1234' 这条SQL，满足条件的记录总共有150条，在原来的Oracle或者MySQL中时，可以直接查询出来150条记录；换成连接Mycat时，如果sqlMaxLimit的值没有修改，那么查询出来的数据只有100条，另外50条数据就没有查询出来，从而导致功能异常；如果在查询的SQL中加上Limit150，就可以将数据一次性查询出来。因此，使用Mycat的同学要特别注意一点，要么在你的SQL里面加上Limit，要么修改sqlMaxLimit的值（如适当增大到10000），配置过大也不行，一般在一次查询返回10000条数据时，应用程序就要考虑使用分页了。
5、全量数据分页排序导致服务器CPU高
使用Mycat的注解，注解可以指定在某一个具体的分片上查询。注解的使用方式
/*!mycat:sql=注解的sql语句*/真正执行sql，使用时将=后的"注解sql语句"替换为需要的sql语句
其原理，百度待续....
6、主从复制延时
在sql语句中添加/*balance*?
eg：/*balance*/ select * from t_node n where n.id = '123456'
三、微服务的简介
1、单体架构：是一种软件架构模式，通常是指系统业务服务端由一个比较大的服务构成，服务内部可以采用组件化、模块化解耦，通过多实例部署实现扩展，运行于一个进程中。
2、面向服务的架构（SOA）：是一个架构风格，它将应用程序的不同功能单元（服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。
3、服务化架构：是一种软件架构模式，采用该架构模式的系统主要由一系列服务构成，服务之间只能基于接口契约进行协作并通过轻量级的通信机制进行通信。具备如下特征：服务组合编排、去中心化数据、演进式设计。
4、微服务架构（业界）：是一种软件架构模式，采用该架构模式的系统主要由一系列微服务构成，微服务之间只能基于接口契约进行协作并通过轻量级的通信机制进行通信。具备如下特征：智能端点与哑管道、去中心化治理、去中心化数据、基础设施自动化、Design For Failure、演进式设计。
四、App开放接口api安全性—Token签名sign的设计与实现
五、分布式锁的介绍
https://blog.csdn.net/tzs_1041218129/article/details/80086991

---------------分隔线-------SecurityString---

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.org.support.cbb.util.security.CodeCCUtils;

/*
 * 创建日期 2010-6-21
 *
 * 更改所生成文件模板为
 * 窗口 > 首选项 > Java > 代码生成 > 代码和注释
 */

/**
 *
 * 该类用于安全整改对各种参数进行安全性校验，以防止SQL注入、跨站脚本
 * 
 * 
 * 窗口 > 首选项 > Java > 代码生成 > 代码和注释
 */
public class SecurityString
{
    
    // sql 注入关键字
    private static String sqlInjectionStr =
        "'|and|exec|insert|select|delete|update|count|*|%|chr|mid|master|truncate|char|declare|; |or|--|+";
    
    private static final Logger LOGGER = LoggerFactory.getLogger(SecurityString.class);
    
    /**
     * SecurityString
     */
    public SecurityString()
    {
    }
    
    public static String unescape(String st)
    {
        if ((null) == st || (st.length() < 1))
        {
            return "";
        }
        
        try
        {
            StringBuffer tmp = new StringBuffer();
            
            tmp.ensureCapacity(st.length());
            
            int lastPos = 0, pos = 0;
            
            char ch;
            
            while (lastPos < st.length())
            {
                pos = st.indexOf("%", lastPos);
                
                if (pos == lastPos)
                {
                    if (st.charAt(pos + 1) == 'u')
                    {
                        ch = (char)Integer.parseInt(st.substring(pos + 2, pos + 6), 16);
                        tmp.append(ch);
                        lastPos = pos + 6;
                        
                    }
                    else
                    {
                        ch = (char)Integer.parseInt(st.substring(pos + 1, pos + 3), 16);
                        tmp.append(ch);
                        lastPos = pos + 3;
                    }
                }
                else
                {
                    if (pos == -1)
                    {
                        tmp.append(st.substring(lastPos));
                        lastPos = st.length();
                        
                    }
                    else
                    {
                        tmp.append(st.substring(lastPos, pos));
                        lastPos = pos;
                    }
                    
                }
            }
            
            return tmp.toString();
            
        }
        catch (Exception p)
        {
            CodeCCUtils.errorLog(LOGGER, "unescape error", p);
        }
        
        return st;
    }
    
    /**
     * 防止跨站脚本攻击
     * Note: 把文本格式转换成Html格式显示
     *       替换内部的空格和回车，添加<BR>
     *
     * @param  str String --待格式化的字符串
     * @return String
     */
    public static String getHtml(String str)
    {
        //过滤敏感字符
        str = filter(str);
        if (str != null)
        {
            return str.replaceAll("\r\n", "<BR>");
        }
        else
        {
            return "&nbsp;";
        }
    }
    
    /**
     * 防止跨站脚本攻击,不影响空判断
     */
    public static String getHtmlStr(String str)
    {
        //过滤敏感字符
        str = filter(str);
        if (str != null)
        {
            return str.replaceAll("\r\n", "<BR>");
        }
        else
        {
            return str;
        }
    }
    
    // update by t00193728 20151203 修改圈复杂度，复杂度：18->13
    /**
     * 防止跨站脚本攻击
     * 过滤敏感字符
     * 将HTML特殊字符转换为相应的实体字符。
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    /**
     * 过滤特殊字符
     */
    public static String filter(String value)
    {
        
        if (StringUtils.isBlank(value))
        {
            return value;
        }
        
        StringBuffer result = new StringBuffer(value.length() + 50);
        String filtered = null;
        for (int i = 0; i < value.length(); i++)
        {
            filtered = null;
            switch (value.charAt(i))
            {
                case '<':
                    filtered = "&#60;";
                    break;
                case '>':
                    filtered = "&#62;";
                    break;
                case '&':
                    filtered = "&amp;";
                    break;
                case '"':
                    filtered = "&#34;";
                    break;
                case '\'':
                    filtered = "&#39;";
                    break;
                case '(':
                    filtered = "&#40;";
                    break;
                case ')':
                    filtered = "&#41;";
                    break;
            }
            
            if (filtered != null)
            {
                result.append(filtered);
            }
            else
            {
                result.append(value.charAt(i));
            }
        }
        
        return result.toString();
    }
    
    /**
     * 防止跨站脚本攻击
     * 过滤敏感字符
     * 将HTML特殊字符转换为相应的实体字符。
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filterBom(String value)
    {
        
        if (value == null || value.length() == 0)
        {
            return value;
        }
        
        StringBuffer result_1 = null;
        String filter = null;
        for (int i = 0; i < value.length(); i++)
        {
            filter = null;
            switch (value.charAt(i))
            {
                case '&':
                    filter = "&amp;";
                    break;
                case '(':
                    filter = "&#40;";
                    break;
                case ')':
                    filter = "&#41;";
                    break;
            }
            
            if (result_1 == null)
            {
                if (filter != null)
                {
                    result_1 = new StringBuffer(value.length() + 50);
                    if (i > 0)
                    {
                        result_1.append(value.substring(0, i));
                    }
                    result_1.append(filter);
                }
            }
            else
            {
                if (filter == null)
                {
                    result_1.append(value.charAt(i));
                }
                else
                {
                    result_1.append(filter);
                }
            }
        }
        
        return result_1 == null ? value : result_1.toString();
    }
    
    /**
     * 对产品线和产品族中的实体码进行转码
     * 转码敏感字符
     * 将实体码转换为对应的特殊字符
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String reverseNaviItem(String value)
    {
        if (StringUtils.isBlank(value))
        {
            return value;
        }
        try
        {
            
            value = value.replaceAll("&#40;", "(");
            value = value.replaceAll("&#41;", ")");
            value = value.replaceAll("&#60;", "<");
            value = value.replaceAll("&#62;", ">");
            value = value.replaceAll("&amp;", "&");
            value = value.replaceAll("&#34;", "\"");
            value = value.replaceAll("&#39;", "\'");
        }
        catch (Exception p)
        {
            CodeCCUtils.errorLog(LOGGER, "reverseNaviItem error", p);
        }
        return value;
    }
    
    /**
     * 对产品线和产品族中的实体码进行转码
     * 转码敏感字符
     * 将实体码转换为对应的特殊字符
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String reverseNaviItemBom(String value)
    {
        
        if (value == null || value.length() == 0)
        {
            return value;
        }
        try
        {
            
            value = value.replaceAll("&#40;", "(");
            value = value.replaceAll("&#41;", ")");
            value = value.replaceAll("&amp;", "&");
        }
        catch (Exception p)
        {
            CodeCCUtils.errorLog(LOGGER, "reverseNaviItemBom error", p);
        }
        return value;
    }
    
    /**
     * 对标题的双引号及'/'进行转义
     * 
     * 
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
//    public static String filterTitle(String value)
//    {
//        if (value == null || value.length() == 0)
//        {
//            return value;
//        }
//        StringBuffer result = null;
//        for (int i = 0; i < value.length(); i++)
//        {
//            if (value.charAt(i) == '"')
//            {
//                if (result == null)
//                {
//                    result = new StringBuffer(value.length() + 50);
//                    if (i > 0)
//                    {
//                        result.append(value.substring(0, i - 1));
//                    }
//                }
//                result.append("\\");
//                result.append(value.charAt(i));
//            }
//            else
//            {
//                if (result == null)
//                {
//                    result = new StringBuffer(value.length() + 50);
//                }
//                result.append(value.charAt(i));
//            }
//        }
//        return result == null ? value : result.toString();
//        
//    }
    
    /**
     * 对标题的双引号进行实体码转义
     * 
     * 
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filterQuotation(String value)
    {
        if (StringUtils.isBlank(value))
        {
            return value;
        }
        value = value.replaceAll("\"", "&#34;");
        return value;
    }
    
    public static String filterDecomQuotation(String value)
    {
        if (value == null || value.length() == 0)
        {
            return value;
        }
        value = value.replaceAll("&#34;", "\"");
        return value;
    }
    
    /**
     * 获取安全反转义字符
     */
    public static String getSecurityString(String val)
    {
        val = val.replaceAll("&#60;", "<");
        val = val.replaceAll("&#62;", ">");
        val = val.replaceAll("&amp;", "&");
        val = val.replaceAll("&#34;", "\"");
        val = val.replaceAll("&#39;", "'");
        val = val.replaceAll("&#40;", "(");
        val = val.replaceAll("&#41;", ")");
        return val;
    }
    
    /**
     * 防止SQL注入
     * 验证字符类型不能包含特殊字符
     * 检测单引号和一些SQL关键字
     *
     * @param string
     * @return
     */
    public static boolean checkNonlicetCharacters(String string)
    {
        boolean flag = false;
        //过滤关键字-*
        if (StringUtils.isNotBlank(string))
        {
            //转换成小写字符
            String lowerCase = string.toLowerCase();
            
            if (lowerCase.indexOf("'") >= 0)
            {
                flag = true;
            }
        }
        
        return flag;
    }
    
    public static boolean checkNonlicetCharacters(String[] strArray)
    {
        boolean flag = false;
        for (int i = 0, j = strArray.length; i < j; i++)
        {
            //过滤关键字
            String strPar = strArray[i];
            // 不许出现单引号"(", "%", "/*", "*/",
            
            if (null != strPar)
            {
                if (strPar.indexOf("'") >= 0)
                {
                    flag = true;
                }
            }
            
        }
        
        return flag;
    }
    
    /**
     * 防止SQL注入
     * 将拼接SQL参数中的单个单引号替换成两个单引号，仅用于动态拼接SQL且使用Statement的情况
     * 使用PreparedStatement时不需要调用此方法
     *
     *
     * @param string
     * @return
     */
    public static String getValidSQLPara(String string)
    {
        if (string == null || string.length() == 0)
        {
            return string;
        }
        return string.replaceAll("'", "''");
    }
    
    
    public static String replaceSQL(String str)
    {
        if (StringUtils.isBlank(str))
        {
            return str;
        }
        if (StringUtils.contains(str, "'"))
        {
            str = StringUtils.replace(str, "'", "''");
        }
        if (StringUtils.equals(str, "\\"))
        {
            str = "\\\\";
        }
        return str;
    }
    
    /**
     * 对标题的/进行转义\/
     * 
     * 
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
//    public static String filterBias(String value)
//    {
//        if (StringUtils.isEmpty(value))
//        {
//            return value;
//        }
//        
//        StringBuffer result = null;
//        for (int i = 0; i < value.length(); i++)
//        {
//            if (value.charAt(i) == '/')
//            {
//                if (result == null)
//                {
//                    result = new StringBuffer(value.length() + 50);
//                    if (i > 0)
//                    {
//                        result.append(value.substring(0, i - 1));
//                    }
//                }
//                result.append("\\/");
//            }
//            else
//            {
//                if (result == null)
//                {
//                    result = new StringBuffer(value.length() + 50);
//                }
//                result.append(value.charAt(i));
//            }
//        }
//        return result == null ? value : result.toString();
//        
//    }
    
    // update by t00193728 20151203 修改圈复杂度，复杂度：16->12
    /**
     * 防止跨站脚本攻击
     * 过滤敏感字符
     * 将HTML特殊字符转换为相应的实体字符。
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filterJson(String value)
    {
        
        if (StringUtils.isBlank(value))
        {
            return value;
        }
        
        //        StringBuffer resultSb_1 = null;
        StringBuffer resultSb_1 = new StringBuffer(value.length() + 50);
        String filteredStr = null;
        for (int i = 0; i < value.length(); i++)
        {
            filteredStr = null;
            switch (value.charAt(i))
            {
                case '<':
                    filteredStr = "&#60;";
                    break;
                case '>':
                    filteredStr = "&#62;";
                    break;
                case '&':
                    filteredStr = "&amp;";
                    break;
                case '\'':
                    filteredStr = "&#39;";
                    break;
                case '(':
                    filteredStr = "&#40;";
                    break;
                case ')':
                    filteredStr = "&#41;";
                    break;
            }
            
            //            if (resultSb_1 == null) {
            //                if (filteredStr != null) {
            //                    resultSb_1 = new StringBuffer(value.length() + 50);
            //                    if (i > 0) {
            //                        resultSb_1.append(value.substring(0, i));
            //                    }
            //                    resultSb_1.append(filteredStr);
            //                }
            //            } else {
            //                if (filteredStr == null) {
            //                    resultSb_1.append(value.charAt(i));
            //                } else {
            //                    resultSb_1.append(filteredStr);
            //                }
            //            }
            
            if (!StringUtils.isBlank(filteredStr))
            {
                resultSb_1.append(filteredStr);
            }
            else
            {
                resultSb_1.append(value.charAt(i));
            }
        }
        
        return resultSb_1.toString();
    }
    
    public static String subString(String value, int length)
    {
        
        String retstr = "";
        if (StringUtils.isEmpty(value))
        {
            return retstr;
        }
        //中文字符
        String chinese = "[u0391-uFFE5]";
        //长度
        int valueLength = 0;
        //字符长度
        int str_len = value.length();
        
        for (int i = 0; i < str_len; i++)
        {
            /* 获取一个字符 */
            String temp = value.substring(i, i + 1);
            /* 判断是否为中文字符 */
            valueLength++;
            if (!temp.matches(chinese))
            {
                valueLength++;
            }
            if (valueLength > length)
            {
                retstr = retstr.concat("...");
                return retstr;
            }
            retstr = retstr.concat(temp);
        }
        return retstr;
    }
    
    /**
     * 判断是否含有sql注入语句
     * @param strValue
     * @return
     */
    public static boolean isSqlInjection(String strValue)
    {
        
        // 若是null 或者 “ ” ，直接返回
        if (StringUtils.isBlank(strValue))
        {
            return false;
        }
        //转换成小写
        String lowerValue = strValue.toLowerCase();
        //通过|拆分sql
        String[] arrKeyword = StringUtils.split(sqlInjectionStr, "|");
        
        if (arrKeyword != null)
        {
            for (String keyword : arrKeyword)
            {
                if (lowerValue.indexOf(keyword) >= 0)
                {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * 将特殊符号替换为下划线
     * <功能详细描述>
     * @param str 待转换的字符串
     * @return [参数说明] 替换特殊字符后的字符串
     *
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static String replaceSpecial2Underline(String str)
    {
        str = str.replaceAll("'|<|>|%|&|/|\\*|\\|@|#|\\$|~|\\^|\\?", "_");
        return str;
    }
}
-----------分隔线------CodeCCUtils
package com.org.support.cbb.util.security;

import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.owasp.esapi.ESAPI;
import org.slf4j.Logger;

import com.org.support.cbb.util.exception.SupportException;

/**
 * @see  [相关类/方法]
 * @since  Support/子系统名/版本
 */
public class CodeCCUtils
{
    enum LogLevel
    {
        DEBUG, WARN, INFO, ERROR
    }
    
    public final static int MAX_MSG_LEN = Integer.MAX_VALUE;
    
    public static void errorLog(Logger gol, String msg, Throwable e)
    {
        log(LogLevel.ERROR, gol, msg, e);
    }
    
    public static void warnLog(Logger gol, String msg, Throwable e)
    {
        log(LogLevel.WARN, gol, msg, e);
    }
    
    public static void infoLog(Logger gol, String msg, Throwable e)
    {
        log(LogLevel.INFO, gol, msg, e);
    }
    
    public static void debugLog(Logger gol, String msg, Throwable e)
    {
        log(LogLevel.DEBUG, gol, msg, e);
    }
    
    public static void log(LogLevel level, Logger gol, String msg, Throwable e)
    {
        if (null == gol)
        {
            return;
        }
        
        try
        {
            /**
             * encapsulate our own exception for FORTIFY.System_Information_Leak--Internal
             */
            throw new SupportException(msg, e);
        }
        catch (SupportException p)
        {
            String gsm = clearLogForging(msg);
            Throwable t = p.getCause();

            switch (level)
            {
                case DEBUG:
                    gol.debug("{}", gsm, t);
                    break;
                case WARN:
                    gol.warn("{}", gsm, t);
                    break;
                case INFO:
                    gol.info("{}", gsm, t);
                    break;
                case ERROR:
                    gol.error("{}", gsm, t);
                    break;
                default:
                    gol.info("{}", gsm, t);
                    break;
            }
        }
    }

    /**
     * clear TrustViolation warning
     * @param message
     * @return
     * @see [类、类#方法、类#成员]
     */
    public static String clearTrustViolation(String message)
    {
      if (StringUtils.isBlank(message))
      {
        return message;
      }

      String clean = StringEscapeUtils.escapeHtml4(message);

      return clean;
    }
    
    /**
     * clear FORTIFY.Log_Forging warning
     * @param message
     * @return
     * @see [类、类#方法、类#成员]
     */
    public static String clearLogForging(String message)
    {
        if (StringUtils.isBlank(message))
        {
            return message;
        }
        
        /**
         * check max length & dummy regex for FORTIFY.Log_Forging
         */
        if (message.length() > MAX_MSG_LEN-10)
        {
            message = "the length of msg is greatter than integer.maxvalue";
            return message;
        }
        
        String clean = message.replace('\n', '_').replace('\r', '_');
        if (ESAPI.securityConfiguration().isLogEncodingRequired())
        {
            clean = ESAPI.encoder().encodeForHTML(message);
            if (!message.equals(clean))
            {
                clean += " (Encoded)";
            }
        }
        
        return clean;
    }
}
