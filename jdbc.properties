
一、consul配置中心(3个server，1个client)部署UR
active采用的主备配置
dubbo注册中心，zookeeper的集群
Redis集群(3主4从)
ElasticSearch(集群节点在3个以上)
NAS/Ceph集群
flyway的集成
二、获取本文文件字符编码，使用cpdetector第三方jar包
三、http://www.cnblogs.com/zcy_soft/p/3566208.html、https://blog.csdn.net/kxcfzyk/article/details/38613861

------------DubboProperties--------分隔线------
import org.springframework.boot.context.properties.ConfigurationProperties;

import com.alibaba.dubbo.config.ApplicationConfig;
import com.alibaba.dubbo.config.ProtocolConfig;
import com.alibaba.dubbo.config.RegistryConfig;

@ConfigurationProperties(prefix = "spring.dubbo")  
public class DubboProperties {

    private String scan;

    private ApplicationConfig application;

    private RegistryConfig registry;

    private ProtocolConfig protocol;
    
    private String configCenterUrl;
    
    public String getScan() {
        return scan;
    }

    public void setScan(String scan) {
        this.scan = scan;
    }

    public ApplicationConfig getApplication() {
        return application;
    }

    public void setApplication(ApplicationConfig application) {
        this.application = application;
    }

    public RegistryConfig getRegistry() {
        return registry;
    }

    public void setRegistry(RegistryConfig registry) {
        this.registry = registry;
    }

    public ProtocolConfig getProtocol() {
        return protocol;
    }

    public void setProtocol(ProtocolConfig protocol) {
        this.protocol = protocol;
    }

    public String getConfigCenterUrl()
    {
        return configCenterUrl;
    }

    public void setConfigCenterUrl(String configCenterUrl)
    {
        this.configCenterUrl = configCenterUrl;
    }
}
-----------DubboAutoConfiguration-----分割线---
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.alibaba.dubbo.common.Constants;
import com.alibaba.dubbo.common.URL;
import com.alibaba.dubbo.common.utils.UrlUtils;
import com.alibaba.dubbo.config.ApplicationConfig;
import com.alibaba.dubbo.config.ProtocolConfig;
import com.alibaba.dubbo.config.RegistryConfig;
import com.huawei.support.cbb.util.configuration.KVConfiguration;

@Configuration
@EnableConfigurationProperties(DubboProperties.class)
public class DubboAutoConfiguration
{
    /**
     * 调用dubbo依赖的配置中心地址
     */
    private static final String registryUrl = "support/zookeeper/url";
    /**
     * registry.timeout
     */
    private static final String registryTimeout = "support/zookeeper/registry.timeout";
    /**
     * registry.session
     */
    private static final String registrySession = "support/zookeeper/registry.session";
    
    @Autowired
    private DubboProperties dubboProperties;
    
    @Value("${server.context-path}")
    private String contextPath;

    @Bean
    public ApplicationConfig requestApplicationConfig() 
    {
        String applicationName = "";
        if (contextPath != null)
        {
            applicationName = contextPath.substring(contextPath.indexOf("/") + 1);
            ApplicationConfig ac = new ApplicationConfig(applicationName);
            dubboProperties.setApplication(ac);
        }
        
        System.setProperty("dubbo.application.name", dubboProperties.getApplication().getName());
        return dubboProperties.getApplication();
    }

    @SuppressWarnings("static-access")
    @Bean
    public RegistryConfig requestRegistryConfig() {

        String configCenterUrl = dubboProperties.getConfigCenterUrl();
        // 获取注册中心zookeeper地址
        KVConfiguration kvConfiguration = new KVConfiguration(configCenterUrl);
        String registryAddress = kvConfiguration.getValue(registryUrl);
        RegistryConfig registryConfig = new RegistryConfig(registryAddress);
        registryConfig.setProtocol(dubboProperties.getProtocol().getName());
        registryConfig.setTimeout(NumberUtils.toInt(kvConfiguration.getValue(registryTimeout)));
        registryConfig.setSession(NumberUtils.toInt(kvConfiguration.getValue(registrySession)));
        dubboProperties.setRegistry(registryConfig);
        
        //将注册 中心的地址写入环境变量，避免日志中出现找不到注册中心的异常
        Map<String, String> defaults = new HashMap<String, String>();
        defaults.put(Constants.PROTOCOL_KEY, dubboProperties.getProtocol().getName());
        URL url = UrlUtils.parseURL(registryAddress, defaults);
        if (url != null)
        {
            String urlFullString = url.toFullString();
            
            if (StringUtils.isNotBlank(urlFullString))
            {
                System.setProperty("dubbo.registry.address", urlFullString);
            }
        }       
        return dubboProperties.getRegistry();
    }

    @Bean
    public ProtocolConfig requestProtocolConfig() {
        return dubboProperties.getProtocol();
    }
}
-----------KVConfiguration---分隔线---
import java.util.List;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.huawei.support.cbb.util.security.CodeCCUtils;
import com.orbitz.consul.Consul;
import com.orbitz.consul.KeyValueClient;

/**
 * 从Consul配置中心读取key/value
 */
public class KVConfiguration
{
    private static final Logger LOG = LoggerFactory.getLogger(KVConfiguration.class);
    
    private static KeyValueClient kvClient;
    
    public KVConfiguration()
    {
        
    }
    
    public KVConfiguration(String url)
    {
        if (StringUtils.isBlank(url))
        {
            throw new RuntimeException("in KVConfiguration(): url is null");
        }
        
        Consul consul = Consul.builder().withUrl(url).build();
        if (null == consul)
        {
            throw new RuntimeException("in KVConfiguration(): consul build return null. url=" + url);
        }
        
        kvClient = consul.keyValueClient();
        if (null == kvClient)
        {
            throw new RuntimeException("in KVConfiguration(): kvClient is null. url=" + url);
        }
    }
    
    public static String getValue(String key)
    {
        try
        {
            return kvClient.getValueAsString(key).get();
        }
        catch (Exception e)
        {
            CodeCCUtils.errorLog(LOG, "in getValue(): get() exception. key=" + key, e);
            return null;
        }
    }
    
    public static List<String> getValues(String key)
    {
        try
        {
            return kvClient.getValuesAsString(key);
        }
        catch (Exception e)
        {
            CodeCCUtils.errorLog(LOG, "in getValues(): get() exception. key=" + key, e);
            return null;
        }
    }   
}
-------SupportEhCache--分隔线
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import javax.jms.Topic;

import net.sf.ehcache.Ehcache;
import net.sf.ehcache.Element;

import org.slf4j.LoggerFactory;
import org.springframework.cache.ehcache.EhCacheCache;

import org.springframework.jms.core.JmsTemplate;

import com.huawei.support.ehcache.distribution.CacheEvent;
import com.huawei.support.ehcache.distribution.EhCacheMessageCreator;

/**
 * 
 * EhCache缓存类
 */
public class SupportEhCache extends EhCacheCache
{
    private SupportEhCacheManager manager;
    
    protected static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(SupportEhCache.class);
    
    //单线程、有界队列线程池，用于异步发topic消息，超过队列大小时，直接丢弃消息不抛异常，不阻塞查询业务
    public final static ThreadPoolExecutor senderExecutor = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS,
        new ArrayBlockingQueue<Runnable>(10000), new ThreadPoolExecutor.DiscardPolicy());
    
    public SupportEhCache(Ehcache ehcache)
    {
        super(ehcache);
    }
    
    /**
     * 添加除缓存对象到缓存中，并发送ActiveMQ JMS消息进行集群的缓存复制
     * @param key
     * @param value
     * @see DsdpEhCache.put(Object key, Object value)
     */
    public void put(Object key, Object value)
    {
        //写入缓存.
        this.getNativeCache().put(new Element(key, value));
        //封装CacheEvent.
        CacheEvent cacheEvent = new CacheEvent(CacheEvent.PUT);
        cacheEvent.setCacheName(this.getName());
        cacheEvent.setKey(key);
        cacheEvent.put(key, value);
        LOGGER.info("put element key:{},value:{} in native cache,name:{}",
                new Object[] { key, value, this.getName() });
        //发送JMS消息.
        sendMessage(cacheEvent);
        
    }
    
    /**
     * 从缓存中删除缓存对象，并发送ActiveMQ JMS消息进行集群的缓存复制
     * @param key
     * @see DsdpEhCache.remove(Object key)
     */
    public void remove(Object key)
    {
        //从缓存中删除缓存对象
        this.getNativeCache().remove(key);
        CacheEvent cacheEvent = new CacheEvent(CacheEvent.REMOVE);
        cacheEvent.setCacheName(this.getName());
        cacheEvent.setKey(key);
        
        LOGGER.info("Before clear native cache,name:{}, key:{}", new Object[] {
                this.getName(), key });
        //发送JMS消息.
        sendMessage(cacheEvent);
    }
    
    /**
     * {@inheritDoc}
     */
    public void evict(Object key)
    {
        remove(key);
    }
    
    /**
     * 发送ActiveMQ JMS消息
     * @param cacheEvent
     * @see DsdpEhCache.sendMessage(CacheEvent cacheEvent)
     */
    private void sendMessage(CacheEvent cacheEvent)
    {
    	//发送JMS消息.
        JmsTemplate jmsTemplate = manager.getJmsTemplate();
        if(jmsTemplate == null)
        {
            LOGGER.info("没有配置JMSTemplate,无需发送ActiveMQ JMS消息进行Cache Replicator.");
        }
        else
        {
            Topic topic = manager.getEhcacheServerTopic();
            if (topic == null)
            {
                LOGGER.info("没有配置ActiveMQ Topic,无需发送ActiveMQ JMS消息进行Cache Replicator.");
            }
            else
            {
                //异步发送消息
                Runnable sender = new Runnable()
                {
                    @Override
                    public void run()
                    {
                        try
                        {
                            LOGGER.info("send ehcache topic message.");
                            jmsTemplate.send(topic, new EhCacheMessageCreator(cacheEvent));
                        }
                        catch (Throwable e)
                        {
                            LOGGER.warn("send ehcache topic message error!");
                        }
                    }
                };
                try
                {
                    senderExecutor.execute(sender);
                }
                catch (Throwable e)
                {
                    LOGGER.error("send ehcache topic message threadPool execute failed! Exception is "+e.getMessage());
                }
            }
        }
    }
    
    public SupportEhCacheManager getManager()
    {
        return manager;
    }

    public void setManager(SupportEhCacheManager manager)
    {
        this.manager = manager;
    }
}
-------EhCacheMessageCreator-----分隔线
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;

public class EhCacheMessageCreator implements MessageCreator
{
    private Serializable obj;
    
    public Serializable getObj()
    {
        return obj;
    }
    
    public void setObj(Serializable obj)
    {
        this.obj = obj;
    }
    
    /***
     * 构造函数
     * @param obj
     */
    public EhCacheMessageCreator(Serializable obj)
    {
        this.obj = obj;
    }
    
    /***
     * 创建消息
     */
    public Message createMessage(Session session) throws JMSException
    {
        return session.createObjectMessage(obj);
    }

    /**
     * @return
     */
    @Override
    public int hashCode()
    {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((obj == null) ? 0 : obj.hashCode());
        return result;
    }

    /**
     * @param obj
     * @return
     */
    @Override
    public boolean equals(Object obj)
    {
        if (this == obj)
        {
            return true;
        }

        if (obj == null)
        {
            return false;
        }
        
        if (getClass() != obj.getClass())
        {
            return false;
        }
        
        EhCacheMessageCreator other = (EhCacheMessageCreator) obj;
        if (this.obj == null)
        {
            if (other.obj != null)
            {
                return false;
            }
        }
        else if (!this.obj.equals(other.obj))
        {
            return false;
        }
        
        return true;
    }
}
----------InetAddressUtils----分隔线-
import java.net.InetAddress;
import java.net.UnknownHostException;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * IP地址转换工具.
 */
public class InetAddressUtils
{
    private static Logger logger = LoggerFactory.getLogger(InetAddressUtils.class);
    /**
     * IPv4地址长度
     */
    public static final int INET_ADDR_IPV4_LEN = 4;
    
    /**
     * 将一个整数形式的IP地址转换成数组形式的IP地址.
     * 例如 ：12345678 => [192, 168, 1, 1]
     * 
     * @param address
     *              整数形式的IP地址
     * @return 数组形式的IP地址
     */
    public static int[] toAddressArray(int address)
    {
        int[] addr = new int[4];
        
        addr[0] = (int)((address >>> 24) & 0xFF);
        addr[1] = (int)((address >>> 16) & 0xFF);
        addr[2] = (int)((address >>> 8) & 0xFF);
        addr[3] = (int)(address & 0xFF);
        return addr;
    }
    
    /**
     * 将一个数组形式的IP地址转换成一个整数形式的IP地址
     * 例如 ：[192, 168, 1, 1] => 12345678
     * 
     * @param addr
     *             数组形式的IP地址
     * @return 整数形式的IP地址
     */
    public static int toAddressInteger(int addr[])
    {
        int address = 0;
        if (addr == null)
        {
            throw new NullPointerException();
        }
        
        if (addr.length != INET_ADDR_IPV4_LEN)
        {
            throw new IllegalArgumentException();
        }
        
        address = addr[3] & 0xFF;
        address |= ((addr[2] << 8) & 0xFF00);
        address |= ((addr[1] << 16) & 0xFF0000);
        address |= ((addr[0] << 24) & 0xFF000000);
        return address;
    }
    
    /**
     * 将一个整数形式的IP地址转换为转换成数组形式的IP地址.
     * 例如 ：12345678 => "192.168.1.1" 
     * 
     * @param address
     *              IP地址字符串
     * @return 数组形式的IP地址
     */
    public static int[] toAddressArray(String address)
    {
        String[] addrStr = address.split("\\.");
        if (addrStr.length != INET_ADDR_IPV4_LEN)
        {
            logger.error("IP's format is wrong");
            throw new IllegalArgumentException("IP's format is wrong");
        }
        
        int[] addr = new int[INET_ADDR_IPV4_LEN];
        int value = 0;
        
        for (int i = 0; i < INET_ADDR_IPV4_LEN; i++)
        {
            value = Integer.parseInt(addrStr[i]);
            if (value < 0 || value > 0xff)
            {
                logger.error("IP's value is wrong");
                throw new IllegalArgumentException("IP's value is wrong");
            }
            
            addr[i] = (int)(value & 0xFF);
        }
        
        return addr;
    }
    
    /**
     * 将一个字符串形式【点分十进制】的IP地址转换为转换成一个整数形式的IP地址.
     * 例如 ："192.168.1.1" => 12345678
     * 
     * @param address
     *              一个字符串形式【点分十进制】的IP地址
     * @return 整数形式的IP地址
     */
    public static int toAddressInteger(String address)
    {
        int[] addr = toAddressArray(address);
        return toAddressInteger(addr);
    }
    
    /**
     * 将一个数组形式的IP地址转换为转换成一个字符串形式【点分十进制】的IP地址.
     * 例如 ：[192, 168, 1, 1] => "192.168.1.1"
     * 
     * @param address
     *               数组形式的IP地址
     * @return 字符串形式【点分十进制】的IP地址
     */
    public static String toAddressString(int addr[])
    {
        if (addr == null)
        {
            throw new NullPointerException();
        }
        
        if (addr.length != INET_ADDR_IPV4_LEN)
        {
            throw new IllegalArgumentException();
        }
        
        return String.format("%s.%s.%s.%s", addr[0], addr[1], addr[2], addr[3]);
    }
    
    /**
     * 将一个整数形式的IP地址转换为转换成一个字符串形式【点分十进制】的IP地址.
     * 例如 ：12345678 => "192.168.1.1"
     * 
     * @param address
     *               整数形式的IP地址
     * @return 字符串形式【点分十进制】的IP地址
     */
    public static String toAddressString(int address)
    {
        int addr[] = toAddressArray(address);
        return toAddressString(addr);
    }
    
//    public static void main(String[] args)
//    {
//        int addrInt = 183156544;
//        String address = "10.234.191.64";
//        int[] addrArry = {10, 234, 191, 64};
//        
//        // 测试IP地址 数组转整数
//        addrInt = toAddressInteger(addrArry);
//        logger.info("toAddressInteger : " + addrInt);
//        
//        // 测试IP地址 字符串转整数       
//        addrInt = toAddressInteger(address);
//        logger.info("toAddressInteger : " + addrInt);
//        
//        
//        // 测试IP地址 整数转数组         
//        addrArry = toAddressArray(addrInt);
//        logger.info("toAddressArray : " + "[" + addrArry[0] + "." + addrArry[1] + "."
//            + addrArry[2] + "." + addrArry[3] + "]");
//        
//        // 测试IP地址 字符串转数组
//        int[] addr = toAddressArray(address);
//        logger.info("toAddressArray : " + "[" + addr[0] + "." + addr[1] + "." + addr[2]
//            + "." + addr[3] + "]");
//
//        
//        // 测试IP地址 数组转字符串
//        address = toAddressString(addr);
//        logger.info("toAddressString : " + address);
//        
//        // 测试IP地址 整数转字符串
//        address = toAddressString(addrInt);
//        logger.info("toAddressString : " + address);
//    }
    
    
    /**
     * 得到本地的机器名
     * @return
     */
    public static String getMachinName()
    {
        InetAddress a;
        try
        {
            a = InetAddress.getLocalHost();
            return a.getHostName();
        }
        catch (UnknownHostException e)
        {
            return StringUtils.EMPTY;
        }
    }
    

    /**
     * 得到本地的机器名，若为空则返回“unknowHostName”
     * @return
     */
    public static String getMachineName()
    {
        String machineName = getMachinName();
        if(StringUtils.isBlank(machineName))
        {
            machineName = "unknowHostName";
        }
        return machineName;
    }
}
------ConfigException----分隔线
-/**
 * Exception for configuration utility.
 * 发生配置文件错误，例如找不到文件，或者格式有误之类所抛出的异常。
 * 为RuntimeException可以根据需要去捕获，或终止.
 * 
public class ConfigException extends RuntimeException {

	/**
	 * serialVersionUID.
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * 默认构造函数.
	 */
	public ConfigException() {
		super();
	}

	/**
	 * 构造函数.
	 * 
	 * @param message
	 *            异常信息
	 * @param cause
	 *            原异常
	 */
	public ConfigException(final String message, final Throwable cause) {
		super(message, cause);
	}

	/**
	 * 构造函数.
	 * 
	 * @param message
	 *            异常信息
	 */
	public ConfigException(final String message) {
		super(message);
	}

	/**
	 * 构造函数.
	 * 
	 * @param cause
	 *            原异常
	 */
	public ConfigException(final Throwable cause) {
		super(cause);
	}

}
-----------ConfigUtil---分隔线
import java.io.FileInputStream;
import java.io.InputStream;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
import java.text.Normalizer;
import java.text.Normalizer.Form;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.huawei.support.cbb.util.classes.ClassUtils;

/**
 * 配置工具类，线程不安全，不应该用来存放全局变量，只用来读取配置，和修改配置.<br />
 * 需要通过在java启动参数中指定
 * 
 * <pre>
 * -Ddsdp.config.file=file1.properties;/file2.properties
 * </pre>
 * 来加载指定的配置文件<br />
 * <br />
 * 不以<code>"/"</code>开头的代表相对于classpath的文件，否则代表绝对路径。 <code>";"</code>
 * 是分隔符，允许加载多个配置文件<br />
 * 不指定情况下，默认加载classpath下的<code>dsdp.properties</code>文件 <br />
 * <br />
 * 不同类型配置读取策略（优先级）：<br />
 * <ul>
 * <li >运行时可修改的属性集，这个属性集初始置空，可用于加载通过注册表配置的属性，并且 可以在运行时修改配置值</li>
 * <li>系统属性集，即可通过{@link System#getProperty(String)}获取的属性</li>
 * <li>配置文件配置的属性值，因为可以加载多个配置文件，默认后加载覆盖先加载</li>
 * </ul>
 */
public final class ConfigUtil
{
    
    private static final Logger logger = LoggerFactory.getLogger(ConfigUtil.class);
    
    private static final String DSDP_CONFIG_KEY = "dsdp.config.file";
    
    private static final String DSDP_PROPERTIES = "dsdp.properties";
    
    private static class ConfigHolder
    {
        static Properties PROPERTIES_FS = new Properties();
        
        static Map<String, String> PROPERTIES_DB = new HashMap<String, String>();
        static
        {
            logger.info("***** Start to load config from files *****");
            String configFiles = System.getProperty(DSDP_CONFIG_KEY);
            if (configFiles == null || configFiles.length() == 0)
            {
                configFiles = DSDP_PROPERTIES;
            }
            for (String path : configFiles.split(";"))
            {
                PROPERTIES_FS.putAll(ConfigUtil.loadProperties(path, false, true));
            }
            logger.info("***** End to load config from files *****");
        }
    }
    public static boolean isNotEmpty(String value)
    {
        return !isEmpty(value);
    }
    
    public static boolean isEmpty(String value)
    {
        return StringUtils.isEmpty(value) || "false".equalsIgnoreCase(value) || "0".equalsIgnoreCase(value)
            || "null".equalsIgnoreCase(value) || "N/A".equalsIgnoreCase(value);
    }
    
    public static boolean isDefault(String value)
    {
        return "true".equalsIgnoreCase(value) || "default".equalsIgnoreCase(value);
    }
    
    private static Pattern VARIABLE_PATTERN = Pattern.compile("\\$\\s*\\{?\\s*([\\._0-9a-zA-Z]+)\\s*\\}?");
    
    /**
     * 替换引用配置，支持配置引用：
     * 
     * <pre>
     * key1=xxx
     * key2=abc${key1}edf
     * </pre> 
     * 将得到<code>key2=abcxxxedf</code>
     * 
     * @param expression
     * @param params
     * @return
     */
    private static String replaceProperty(String expression, Map<String, String> params)
    {
        if (expression == null || expression.length() == 0 || expression.indexOf('$') < 0)
        {
            return expression;
        }
        //codecc修复，归一化字符串
        expression = Normalizer.normalize(expression, Form.NFKC);
        Matcher matcher = VARIABLE_PATTERN.matcher(expression);
        StringBuffer sb = new StringBuffer();
        while (matcher.find())
        { // 逐个匹配
            String key = matcher.group(1);
            String value = System.getProperty(key);
            if (value == null && params != null)
            {
                value = params.get(key);
            }
            if (value == null)
            {
                value = "";
            }
            matcher.appendReplacement(sb, Matcher.quoteReplacement(value));
        }
        matcher.appendTail(sb);
        return sb.toString();
    }
    
    public static void addProperties(Map<String, String> properties)
    {
        if (properties != null)
        {
            ConfigHolder.PROPERTIES_DB = properties;
        }
    }
    
    public static void setProperty(String key, String value)
    {
        ConfigHolder.PROPERTIES_DB.put(key, value);
    }
    
    public static String getProperty(String key)
    {
        return getProperty(key, null);
    }
    
    @SuppressWarnings({"unchecked", "rawtypes"})
    public static String getProperty(String key, String defaultValue)
    {
        Map<String, String> map = ConfigHolder.PROPERTIES_DB;
        String value = map.get(key);
        if (StringUtils.isNotBlank(value))
        {
            return replaceProperty(value, map);
        }
        value = System.getProperty(key);
        if (StringUtils.isNotBlank(value))
        {
            return value;
        }
        Properties properties = ConfigHolder.PROPERTIES_FS;
        return replaceProperty(properties.getProperty(key, defaultValue), (Map)properties);
    }
    
    public static int getIntProperty(String key, int defaultValue)
    {
        String stringValue = getProperty(key, String.valueOf(defaultValue));
        return Integer.parseInt(stringValue);
    }
    
    public static long getLongProperty(String key, long defaultValue)
    {
        String stringValue = getProperty(key, String.valueOf(defaultValue));
        return Long.parseLong(stringValue);
    }
    
    public static boolean getBooleanProperty(String key, boolean defaultValue)
    {
        String stringValue = getProperty(key, String.valueOf(defaultValue));
        return Boolean.parseBoolean(stringValue);
    }
    
    public static double getDoubleProperty(String key, double defaultValue)
    {
        String stringValue = getProperty(key, String.valueOf(defaultValue));
        return Double.parseDouble(stringValue);
    }

    private static Properties loadProperties(String fileName, boolean allowMultiFile, boolean optional)
    {
        logger.info("|--Loading config from {}...");
        Properties properties = new Properties();
        // codecc 修复，字符串校验之前先归一化
        if (StringUtils.isEmpty(fileName))
        {
            return properties;
        }
        else
        {
            fileName = Normalizer.normalize(fileName, Form.NFKC);
        }
        if (fileName.startsWith("/"))
        {
            try
            {
                FileInputStream input = new FileInputStream(fileName);
                try
                {
                    properties.load(input);
                }
                finally
                {
                    input.close();
                }
            }
            catch (Throwable e)
            {
                logger.warn("Failed to load  file from (ingore this file): ");
            }
            return properties;
        }
        
        List<java.net.URL> list = new ArrayList<java.net.URL>();
        try
        {
            Enumeration<java.net.URL> urls = ClassUtils.getClassLoader().getResources(fileName);
            list = new ArrayList<java.net.URL>();
            while (urls.hasMoreElements())
            {
                list.add(urls.nextElement());
            }
        }
        catch (Throwable t)
        {
            logger.warn("Fail to load  file: ");
        }
        
        if (list.size() == 0)
        {
            if (!optional)
            {
                logger.warn("No  found on the class path.");
            }
            return properties;
        }
        
        if (!allowMultiFile)
        {
            if (list.size() > 1)
            {
                String errMsg ="only 1  file is expected, but %d dsdp.properties files found on class path: ";
                logger.warn(errMsg);
            }
            
            // fall back to use method getResourceAsStream
            InputStream inputStream = ClassUtils.getClassLoader().getResourceAsStream(fileName);
            try
            {
                properties.load(inputStream);
            }
            catch (Throwable e)
            {
                logger.warn("Failed to load file from (ingore this file): ");
            }
            finally
            {
                IOUtils.closeQuietly(inputStream);
            }
            return properties;
        }
        
        logger.info("load properties file from ");
        
        for (java.net.URL url : list)
        {
            try
            {
                Properties p = new Properties();
                InputStream input = url.openStream();
                if (input != null)
                {
                    try
                    {
                        p.load(input);
                        properties.putAll(p);
                    }
                    finally
                    {
                        IOUtils.closeQuietly(input);
                    }
                }
            }
            catch (Throwable e)
            {
                logger.warn("Fail to load  file from (ingore this file): ");
            }
        }
        
        return properties;
    }
    
    private static int PID = -1;
    
    public static int getPid()
    {
        if (PID < 0)
        {
            try
            {
                RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
                String name = runtime.getName(); // format: "pid@hostname"
                PID = Integer.parseInt(name.substring(0, name.indexOf('@')));
            }
            catch (Throwable e)
            {
                PID = 0;
            }
        }
        return PID;
    }
    private ConfigUtil()
    {   }    }
--------分隔线---------FileUtils
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileNotFoundException;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;

import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * FileUtil
 * 
 * @author w00207565
 * @version DSDP V100R001C00
 */
public abstract class FileUtils
{
    /**
     * 日志记录
     */
    private final static Logger LOGGER = LoggerFactory.getLogger(FileUtils.class);
    
    /**
     * HTML属性文件夹后缀，保存图片或js,css等文件
     */
    private static final String HTML_FILES_DOT_SUFFIX = ".files";
    
    /**
     * HTML属性文件夹后缀，保存图片或js,css等文件
     */
    private static final String HTML_FILES_UNDERLINE_SUFFIX = "_files";
    
    /**
     * 缓冲区大小
     */
    public static final int BLOCK_SIZE = 4096;
    
    /**
     * 将字节数组写入文件.
     * 
     * @param fileName
     * @param content
     * @throws IOException
     */
    public static void writeContent(String fileName, byte[] content)
        throws IOException
    {
        OutputStream out = null;
        
        File file = org.apache.commons.io.FileUtils.getFile(fileName);
        if (null == file)
        {
            return;
        }
        
        try
        {
            out = new BufferedOutputStream(org.apache.commons.io.FileUtils.openOutputStream(file));
            out.write(content);
            out.flush();
        }
        finally
        {
            IOUtils.closeQuietly(out);
            
        }
    }
    
    /**
     * 将DataHandler写入文件.
     * 
     * @param fileName
     * @param handler
     * @throws IOException
     */
    
    public static void writeContent(String fileName, DataHandler handler)
        throws IOException
    {
        OutputStream out = null;
        File file = org.apache.commons.io.FileUtils.getFile(fileName);
        if (null == file)
        {
            return;
        }
        
        try
        {
            out = new BufferedOutputStream(org.apache.commons.io.FileUtils.openOutputStream(file));
            handler.writeTo(out);
            out.flush();
        }
        finally
        {
            IOUtils.closeQuietly(out);
        }
    }
    
    /**
     * 将输入流写入文件.
     * 
     * @param fileName
     * @param inputStream
     * @throws IOException
     */
    public static void writeContent(String fileName, InputStream inputStream)
        throws IOException
    {
        OutputStream out = null;
        File file = org.apache.commons.io.FileUtils.getFile(fileName);
        if (null == file)
        {
            return;
        }
            
        try
        {
            out = new BufferedOutputStream(org.apache.commons.io.FileUtils.openOutputStream(file));
            int n = 0;
            byte[] buffer = new byte[BLOCK_SIZE];
            while ((n = inputStream.read(buffer)) > 0)
            {
                out.write(buffer, 0, n);
            }
        }
        finally
        {
            IOUtils.closeQuietly(out);
        }
    }
    
    /**
     * 将输入流写入文件.
     *  
     * @param fileName
     * @param inputStream
     * @throws FileNotFoundException, IOException
     */
    public static void writeContent(File fileName, InputStream in)
        throws FileNotFoundException, IOException
    {
        if (null == fileName || null == in)
        {
            return;
        }
        OutputStream out = null;
        try
        {
            out = new BufferedOutputStream(org.apache.commons.io.FileUtils.openOutputStream(fileName));
            byte[] buffer = new byte[BLOCK_SIZE];
            int bytesRead = -1;
            while ((bytesRead = in.read(buffer, 0, buffer.length)) != -1)
            {
                out.write(buffer, 0, bytesRead);
            }
        }
        finally
        {
            IOUtils.closeQuietly(out);
        }
    }
    
    /**
     * 从文件中读取到字节数组中.
     * 
     * @param pathName
     * @throws FileNotFoundException
     *             , IOException
     */
    public static byte[] readContent(String pathName)
        throws FileNotFoundException, IOException
    {
        InputStream in = null;
        File file = org.apache.commons.io.FileUtils.getFile(pathName);
        byte[] byteResults = null;
        try
        {
            in = new BufferedInputStream(org.apache.commons.io.FileUtils.openInputStream(file));
            byteResults = new byte[in.available()];
            in.read(byteResults);
        }
        finally
        {
            IOUtils.closeQuietly(in);
            
        }
        return byteResults;
    }
    
    /**
     * 将源输入流拷贝至目标输出流中.
     * 
     * @param input
     * @param output
     * @throws IOException
     */
    public static void copy(InputStream input, OutputStream output)
        throws IOException
    {
        int n = -1;
        byte[] buffer = new byte[BLOCK_SIZE];
        while ((n = input.read(buffer)) != -1)
        {
            output.write(buffer, 0, n);
        }
    }
    
    /**
     * 将文件读取至DataHandler中.
     * 
     * @param pathName
     * @throws FileNotFoundException
     *             , IOException
     */
    public static DataHandler readData(String pathName)
        throws IOException
    {
        File file = org.apache.commons.io.FileUtils.getFile(pathName);
        DataSource source = (DataSource)new FileDataSource(file);
        return (new DataHandler(source));
    }
    
    /**
     * 删除文件.
     * 
     * @param pathName
     * @return true if successfully deleted, otherwise false
     */
    public static boolean deleteFile(String fileName)
    {
        File file = org.apache.commons.io.FileUtils.getFile(fileName);
        if (null == file || !(file.exists() && file.isFile()))
        {
            return false;
        }
        
        return file.delete();
    }
    
    /**
     * 删除目录
     * 
     * @param dirName
     * @return true if successfully deleted, otherwise false
     */
    public static boolean deleteDirectory(String dirName)
    {
        File file = new File(dirName);
        deleteFile(file);
        return true;
    }
    
    /**
     * 删除目录或文件
     * 
     * @param pathName
     * @return true if successfully deleted, otherwise false
     * @throws SecurityException
     */
    public static void deleteFile(File file)
        throws SecurityException
    {
        if (file.exists())
        {
            // 如果是文件则直接删除
            if (file.isFile())
            {
                file.delete();
            }
            // 否则递归删除其所有子文件
            else if (file.isDirectory())
            {
                File files[] = file.listFiles();
                for (int i = 0; i < files.length; i++)
                {
                    deleteFile(files[i]);
                }
                file.delete();
            }
        }
    }
    
    /**
     * 创建目录或创建其父目录
     * 
     * @param file
     *            文件或目录
     * @throws SecurityException
     */
    public static void createDirectory(File file)
        throws SecurityException
    {
        // 如果是目录且不存在，则创建该目录
        if (file.isDirectory() && !file.exists()) //不是目录而是文件； 是目录但是存在
        {
            file.mkdirs();
        }
        // 如果其父路径不存在，则创建其父路径
        else
        {
            if (file.getParentFile() != null && !file.getParentFile().exists())
            {
                file.getParentFile().mkdirs();
            }
        }
    }
    
    /**
     * 检查某目录或文件是否存在.
     * 
     * @param pathName
     * @return true if the file exists, otherwise false
     * @throws SecurityException	 
     */
    public static boolean isFileExist(String pathName)
    {
        File file = org.apache.commons.io.FileUtils.getFile(pathName);
        return file.exists();
    }
    
    /**
     * 获取某文件的大小
     * 
     * @param filePath
     * @return 文件的大小
     * @throws IOException 
     */
    public static long getFileSize(String filePath)
        throws IOException
    {
        File file = org.apache.commons.io.FileUtils.getFile(filePath);
        
        if (!file.isFile())
        {
            String message = "The file path is not file.";
            LOGGER.error(message);
            throw new IOException(message);
        }
        
        return file.length();
    }
    
    /**
     * 确保某路径名指定的目录存在，若还不存在创建此目录
     * 	 
     * @param pathName
     * @throws SecurityException
     */
    public static void ensurePathExist(String pathName)
        throws SecurityException
    {
        File file = org.apache.commons.io.FileUtils.getFile(pathName);
        
        // 该路径存在则忽略即可
        if (!file.exists())
        {
            file.mkdirs();
        }
    }
    
    public static void ensurePathExist(File file)
        throws SecurityException
    {
        // 该路径存在则忽略即可
        if (!file.exists())
        {
            file.mkdirs();
        }
    }
    
    /**
     * 检查某目录是否存在.
     * 
     * @param dirPath
     * @return true if the file exists, otherwise false
     */
    public static boolean isDirectoryExist(String dirPath)
    {
        File file = org.apache.commons.io.FileUtils.getFile(dirPath);
        return isDirectoryExist(file);
    }
    
    /**
     * 检查某目录是否存在.
     * 
     * @param dirFile
     * @return true if the file exists, otherwise false
     */
    public static boolean isDirectoryExist(File dirFile)
    {
        return (dirFile.isDirectory() && dirFile.exists());
    }
    
    /**
     * 检查是否为目录
     * 
     * @param dirPath
     * @return
     */
    public static boolean isDirectory(String dirPath)
    {
        File file = new File(dirPath);
        
        return file.isDirectory();
    }
    
    /**
     * 检查某目录是否为空目录.
     * 
     * @param dirPath
     * @param filter
     * @return true if the file exists, otherwise false
     */
    public static boolean isDirectoryEmpty(String dirPath)
    {
        File file = new File(dirPath);
        return file.listFiles().length == 0;
    }
    
    /**
     * 检查某目录是否为空目录.
     * 
     * @param dirPath
     * @param filter
     * @return true if the file exists, otherwise false
     */
    public static boolean isDirectoryEmpty(String dirPath, FilenameFilter filter)
    {
        File file = new File(dirPath);
        if (filter == null)
        {
            return file.listFiles().length == 0;
        }
        else
        {
            //修改converity wWX169374
            if (file.listFiles(filter) != null)
            {
                return file.listFiles(filter).length == 0;
            }
            else
            {
                return true;
            }
        }
    }
    
    /**
     * 检查某目录是否为空目录.
     * 
     * @param dirPath
     * @param filter
     * @return true if the file exists, otherwise false
     */
    public static boolean isDirectoryEmpty(String dirPath, FileFilter filter)
    {
        File file = new File(dirPath);
        if (filter == null)
        {
            return file.listFiles().length == 0;
        }
        else
        {
            //修改converity wWX169374
            File[] temp = file.listFiles(filter);
            if (temp == null)
            {
                return true;
            }
            return temp.length == 0;
        }
    }
    
    /**
     * 列举目标目录下顶层的文件列表.
     * 
     * @param dir
     *            待递归列举的目录
     */
    public static void listRootFiles(File sourceDir, List<String> fileList)
    {
        File[] fs = sourceDir.listFiles();
        
        for (int i = 0; i < fs.length; i++)
        {
            // 仅列出顶层目录下的文件，忽略顶层目录中的子文件夹
            if (fs[i].isFile())
            {
                fileList.add(fs[i].getAbsolutePath());
            }
        }
    }
    
    /**
     * 列举目标目录下顶层的文件名称列表.
     * 
     * @param dir
     *            待递归列举的目录
     */
    public static void listRootFileNames(File sourceDir, List<String> fileList)
    {
        File[] fs = sourceDir.listFiles();
        
        for (int i = 0; i < fs.length; i++)
        {
            // 仅列出顶层目录下的文件，忽略顶层目录中的子文件夹
            if (fs[i].isFile())
            {
                fileList.add(fs[i].getName());
            }
        }
    }
    
    /**
     * 递归列举目标目录下的所有文件列表.
     * 
     * @param dir
     *            待递归列举的目录
     * @throws IOException
     */
    public static void listFiles(File sourceDir, List<String> fileList)
    {
        File[] fs = sourceDir.listFiles();
        
        for (int i = 0; i < fs.length; i++)
        {
            if (fs[i].isDirectory())
            {
                listFiles(fs[i], fileList);
            }
            else
            {
                fileList.add(fs[i].getAbsolutePath());
            }
        }
    }
    
    /**
     * 递归列举目标目录下的所有文件列表，同时过滤掉指定的文件名后缀列表
     * 
     * @param dir
     *            待递归列举的目录
     * @throws IOException
     */
    public static void listFiles(File sourceDir, List<String> fileList, List<String> suffixList)
        throws IOException
    {
        File[] fs = sourceDir.listFiles(new FileNameFilter(suffixList));
        
        if (fs != null)
        {
            for (int i = 0; i < fs.length; i++)
            {
                if (fs[i].isDirectory())
                {
                    listFiles(fs[i], fileList);
                }
                else
                {
                    fileList.add(fs[i].getAbsolutePath());
                }
            }
        }
    }
    
    /**
     * 获取文件后缀格式.
     * 
     * @param filePath
     * @return
     */
    public static String getFileSuffix(String filePath)
    {
        if (filePath == null)
        {
            throw new IllegalArgumentException();
        }
        
        int pos = filePath.lastIndexOf('.');
        return pos == -1 ? null : filePath.substring(pos + 1);
    }
    
    /**
     * 获取没有扩展名的文件名.
     * 
     * @param fileName
     * @return
     */
    public static String getFileNameWithoutSuffix(String fileName)
    {
        if (fileName == null)
        {
            throw new IllegalArgumentException();
        }
        
        int pos = fileName.lastIndexOf(".");
        return pos == -1 ? fileName : fileName.substring(0, pos);
    }
    
    /**
     * 获取没有扩展名的文件名.
     * 
     * @param fileName
     * @return
     */
    public static String getFileNameByFilePath(String filePath)
    {
        if (filePath == null)
        {
            throw new IllegalArgumentException();
        }
        
        File file = org.apache.commons.io.FileUtils.getFile(filePath);
        return file.getName();
    }
    
    /**
     * 根据父目录和文件名获取文件的绝对路径.
     * 
     * @param parentDir
     * @param fileName
     * @return
     */
    public static String getAbsolutePath(String parentDir, String fileName)
    {
        File file = new File(parentDir, fileName);
        return file.getAbsolutePath();
    }
    
    /**
     * 获取标准化路径
     * @param path
     * @return
     * @throws IOException
     * @see [类、类#方法、类#成员]
     */
    public static String getCanonicalPath(String path) throws IOException
    {
        File file = new File(path);
        return file.getCanonicalPath();
    }
    
    /**
     * 目录过滤器，过滤掉所有目录.
     */
    public static class DirectoryFilter implements FileFilter
    {
        // 如果File为目录类型，则过滤该目录
        public boolean accept(File file)
        {
            return !file.isDirectory();
        }
    }
    
    /**
    * 文件名称过滤器，过滤掉指定的文件名后缀列表
    */
    public static class FileNameFilter implements FilenameFilter
    {
        /**
         * 文件名后缀列表
         */
        private List<String> suffixList;
        
        /**
         * <构造函数>
         */
        public FileNameFilter(List<String> suffixList)
        {
            this.suffixList = suffixList;
        }
        
        public boolean accept(File dir, String name)
        {
            boolean ret = true;
            String lowerName = name.toLowerCase();
            
            // 如果该文件后缀存在文件名后缀列表中，则表示将其过滤
            for (String suffixName : this.suffixList)
            {
                if (lowerName.endsWith(suffixName))
                {
                    ret = false;
                    break;
                }
            }
            
            return ret;
        }
    }
    
    /**
     * HTML附属文件夹过滤器，过滤掉所有".files"及"_files"等文件夹
     */
    public static class HtmlFoldersFilter implements FileFilter
    {
        public boolean accept(File file)
        {
            if (file.isDirectory())
            {
                // 以".files"及"_files"为结尾的文件夹，均过滤掉
                String dirName = file.getName().toLowerCase();
                return !(dirName.endsWith(HTML_FILES_DOT_SUFFIX) || dirName.endsWith(HTML_FILES_UNDERLINE_SUFFIX));
            }
            
            return true;
        }
    }
}
----------NetUtil---分隔线-----
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.MalformedURLException;
import java.net.NetworkInterface;
import java.net.URL;
import java.net.UnknownHostException;
import java.security.SecureRandom;
import java.util.Enumeration;
import java.util.Map;
import java.util.regex.Pattern;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.huawei.support.cbb.util.security.CodeCCUtils;

public final class NetUtil {
    
    private static final Logger logger = LoggerFactory.getLogger(NetUtil.class);

    public static final String LOCALHOST = "127.0.0.1";

    public static final String ANYHOST = "0.0.0.0";

    private static final int RND_PORT_START = 30000;
    
    private static final int RND_PORT_RANGE = 10000;
    
    //修改codecc
    private static final SecureRandom RANDOM = new SecureRandom();
    
    public static int getRandomPort() {
        return RND_PORT_START + RANDOM.nextInt(RND_PORT_RANGE);
    }

    public static int getAvailablePort() {
        SSLSocket ss = null;
        try {
            SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
            
            ss = (SSLSocket)sslSocketFactory.createSocket();
            ss.bind(null);
            return ss.getLocalPort();
        } catch (IOException e) {
            return getRandomPort();
        } finally {
            if (ss != null) {
                try {
                    ss.close();
                } catch (IOException e) {
                    ss = null;
                }
            }
        }
    }
    
    public static int getAvailablePort(int port) {
    	if (port <= 0) {
    		return getAvailablePort();
    	}
    	for(int i = port; i < MAX_PORT; i ++) {
    	    SSLSocket ss = null;
            try {
                SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
                ss = (SSLSocket)sslSocketFactory.createSocket(LOCAL_ADDRESS, i);
                return i;
            } catch (IOException e) {
            	// continue
                continue;
            } finally {
                if (ss != null) {
                    try {
                        ss.close();
                    } catch (IOException e) {
                        ss = null;
                    }
                }
            }
    	}
    	return port;
    }

    private static final int MIN_PORT = 0;
    
    private static final int MAX_PORT = 65535;
    
    public static boolean isInvalidPort(int port){
        return port > MIN_PORT || port <= MAX_PORT;
    }

    private static final Pattern ADDRESS_PATTERN = Pattern.compile("^\\d{1,3}(\\.\\d{1,3}){3}\\:\\d{1,5}$");

    public static boolean isValidAddress(String address){
    	return ADDRESS_PATTERN.matcher(address).matches();
    }

    private static final Pattern LOCAL_IP_PATTERN = Pattern.compile("127(\\.\\d{1,3}){3}$");
    
    public static boolean isLocalHost(String host) {
        return host != null 
                && (LOCAL_IP_PATTERN.matcher(host).matches() 
                        || host.equalsIgnoreCase("localhost"));
    }

    public static boolean isAnyHost(String host) {
        return "0.0.0.0".equals(host);
    }
    
    public static boolean isInvalidLocalHost(String host) {
        return host == null 
        			|| host.length() == 0
                    || host.equalsIgnoreCase("localhost")
                    || host.equals("0.0.0.0")
                    || (LOCAL_IP_PATTERN.matcher(host).matches());
    }
    
    public static boolean isValidLocalHost(String host) {
    	return ! isInvalidLocalHost(host);
    }

    public static InetSocketAddress getLocalSocketAddress(String host, int port) {
        return isInvalidLocalHost(host) ? 
        		new InetSocketAddress(port) : new InetSocketAddress(host, port);
    }

    private static final Pattern IP_PATTERN = Pattern.compile("\\d{1,3}(\\.\\d{1,3}){3,5}$");

    private static boolean isValidAddress(InetAddress address) {
        if (address == null || address.isLoopbackAddress())
            return false;
        String name = address.getHostAddress();
        return (name != null 
                && ! ANYHOST.equals(name)
                && ! LOCALHOST.equals(name) 
                && IP_PATTERN.matcher(name).matches());
    }
    
    public static String getLocalHost(){
        InetAddress address = getLocalAddress();
        return address == null ? LOCALHOST : address.getHostAddress();
    }
    
    public static String getLocalHostName() {
    	InetAddress address = getLocalAddress();
        return address == null ? LOCALHOST : address.getHostName();
    }
    
    public static String filterLocalHost(String host) {
        if (host == null || host.length() == 0) {
            return host;
        }
        if (host.contains("://")) {
            try {
				URL u = new URL(host);
				if (isInvalidLocalHost(u.getHost())) {
				    return new URL(getLocalHost()).toString();
				}
			} catch (MalformedURLException e) {
				throw new IllegalStateException("Invalid host", e);
			}
        } else if (host.contains(":")) {
            int i = host.lastIndexOf(':');
            if (isInvalidLocalHost(host.substring(0, i))) {
                return getLocalHost() + host.substring(i);
            }
        } else {
            if (isInvalidLocalHost(host)) {
        		return getLocalHost();
        	}
        }
    	return host;
    }
    
    private static volatile InetAddress LOCAL_ADDRESS = null;

    /**
     * 遍历本地网卡，返回第一个合理的IP。
     * 
     * @return 本地网卡IP
     */
    public static InetAddress getLocalAddress() {
        if (LOCAL_ADDRESS != null)
            return LOCAL_ADDRESS;
        InetAddress localAddress = getLocalAddress0();
        LOCAL_ADDRESS = localAddress;
        return localAddress;
    }
    
    public static String getLogHost() {
        InetAddress address = LOCAL_ADDRESS;
        return address == null ? LOCALHOST : address.getHostAddress();
    }
    
    private static InetAddress getLocalAddress0() {
        InetAddress localAddress = null;
        try {
            localAddress = InetAddress.getLocalHost();
            if (isValidAddress(localAddress)) {
                return localAddress;
            }
        } catch (Throwable e) {
            logger.warn("Failed to retriving ip address, ");
        }
        try {
            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
            if (interfaces != null) {
                while (interfaces.hasMoreElements()) {
                    try {
                        NetworkInterface network = interfaces.nextElement();
                        Enumeration<InetAddress> addresses = network.getInetAddresses();
                        if (addresses != null) {
                            while (addresses.hasMoreElements()) {
                                try {
                                    InetAddress address = addresses.nextElement();
                                    if (isValidAddress(address)) {
                                        return address;
                                    }
                                } catch (Throwable e) {
                                    logger.warn("Failed to retriving ip address, " + e.getMessage(), e);
                                }
                            }
                        }
                    } catch (Throwable e) {
                        logger.warn("Failed to retriving ip address, " + e.getMessage(), e);
                    }
                }
            }
        } catch (Throwable e) {
            logger.warn("Failed to retriving ip address, ");
        }
        logger.error("Could not get local host ip address, will use 127.0.0.1 instead.");
        return localAddress;
    }
    
    private static final Map<String, String> hostNameCache = new LRUCache<String, String>(1000);

    public static String getHostName(String address) {
    	try {
    		int i = address.indexOf(':');
    		if (i > -1) {
    			address = address.substring(0, i);
    		}
    		String hostname = hostNameCache.get(address);
    		if (hostname != null && hostname.length() > 0) {
    			return hostname;
    		}
    		InetAddress inetAddress = InetAddress.getByName(address);
    		if (inetAddress != null) {
    			hostname = inetAddress.getHostName();
    			hostNameCache.put(address, hostname);
    			return hostname;
    		}
		} catch (Throwable e) {
			// ignore
		    CodeCCUtils.errorLog(logger, "in getHostName(): exception", e);
		}
		return address;
    }
    
    /**
     * @param hostName
     * @return ip address or hostName if UnknownHostException 
     */
    public static String getIpByHost(String hostName) {
        try{
            return InetAddress.getByName(hostName).getHostAddress();
        }catch (UnknownHostException e) {
            return hostName;
        }
    }

    public static String toAddressString(InetSocketAddress address) {
        return address.getAddress().getHostAddress() + ":" + address.getPort();
    }
    
    public static InetSocketAddress toAddress(String address) {
        int i = address.indexOf(':');
        String host;
        int port;
        if (i > -1) {
            host = address.substring(0, i);
            port = Integer.parseInt(address.substring(i + 1));
        } else {
            host = address;
            port = 0;
        }
        return new InetSocketAddress(host, port);
    }
    
    public static String toURL(String protocol, String host, int port, String path) {
		StringBuilder sb = new StringBuilder();
		sb.append(protocol).append("://");
		sb.append(host).append(':').append(port);
		if( path.charAt(0) != '/' )
			sb.append('/');
		sb.append(path);
		return sb.toString();
	}    
}
----------------分隔线----SecurityString
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.text.Normalizer;
import java.text.Normalizer.Form;
import java.util.regex.Pattern;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
  * 该类用于安全整改对各种参数进行安全性校验，以防止SQL注入、跨站脚本
 * 窗口 > 首选项 > Java > 代码生成 > 代码和注释
 */
public class SecurityString
{
    /**
     * 日志
     */
    private static final Logger LOG = LoggerFactory.getLogger(SecurityString.class);
    
    public static String unescape(String src)
    {
        if ((null) == src || (src.length() < 1))
        {
            return "";
        }
        
        try
        {
            StringBuffer tmp = new StringBuffer();
            
            tmp.ensureCapacity(src.length());
            
            int lastPos = 0, pos = 0;
            
            char ch;
            
            while (lastPos < src.length())
            {
                pos = src.indexOf("%", lastPos);
                
                if (pos == lastPos)
                {
                    if (src.charAt(pos + 1) == 'u')
                    {
                        ch = (char) Integer.parseInt(src.substring(pos + 2, pos + 6), 16);
                        tmp.append(ch);
                        lastPos = pos + 6;
                        
                    }
                    else
                    {
                        ch = (char) Integer.parseInt(src.substring(pos + 1, pos + 3), 16);
                        tmp.append(ch);
                        lastPos = pos + 3;
                    }
                }
                else
                {
                    if (pos == -1)
                    {
                        tmp.append(src.substring(lastPos));
                        lastPos = src.length();
                        
                    }
                    else
                    {
                        tmp.append(src.substring(lastPos, pos));
                        lastPos = pos;
                    }
                    
                }
            }
            
            return tmp.toString();
            
        }
        catch (Exception e)
        {
            CodeCCUtils.errorLog(LOG, "in unescape(): exception", e);
        }
        
        return src;
    }
    
    /**
     * 防止跨站脚本攻击
     * 过滤敏感字符
     * 将HTML特殊字符转换为相应的实体字符。
     * @param value The string to be filtered and returned
     */
    public static String xssFilter(String value)
    {
        
        if (StringUtils.isBlank(value))
        {
            return value;
        }
        
        //XXS去除 alert
        String regexAlert = ".*(alert|prompt|eval|\\.source|Function|function|%0d%0a).*\\(.*\\).*";
        value = Normalizer.normalize(value, Form.NFKC);
        if (value.matches(regexAlert))
        {
            return null;
        }
        
        //XSS 对输入进行过滤，过滤参数中带有   +{toString:alert} +{valueOf:alert} 等特殊字符 DTS2014051509222
        regexAlert = ".*(:|%3A)(\\s|%20)*(alert|prompt|eval|\\.source|Function|function|%0d%0a).*";
        if (value.matches(regexAlert))
        {
            return null;
        }
        
        //XSS 处理windows.location
        regexAlert = ".*(window|location|\\.source|Function|function|%0d%0a).*";
        if (value.matches(regexAlert))
        {
            return null;
        }
        
        regexAlert = ".*(exec|cmdshell|\\.source|Function|function|%0d%0a).*";
        if (value.matches(regexAlert))
        {
            return null;
        }
        
        //XSS去除脚本 <=>
        String regexScript = ".*<.*=.*>.*";
        if (value.matches(regexScript))
        {
            return null;
        }
        
        StringBuffer result = null;
        String filtered = null;
        for (int i = 0; i < value.length(); i++)
        {
            filtered = xssFilterChar(value.charAt(i));
            
            result = appendReplaceChar(value, result, filtered, i);
        }
        return result == null ? value : result.toString();
    }
    
    private static StringBuffer appendReplaceChar(String value, StringBuffer result, String filtered, int i)
    {
        if (result == null)
        {
            if (filtered != null)
            {
                result = new StringBuffer(value.length() + 50);
                if (i > 0)
                {
                    result.append(value.substring(0, i));
                }
                result.append(filtered);
            }
        }
        else
        {
            if (filtered == null)
            {
                result.append(value.charAt(i));
            }
            else
            {
                result.append(filtered);
            }
        }
        return result;
    }
    
    public static String xssFilterChar(char ch)
    {
        switch (ch)
        {
            case '<':
                return "&#60;";
            case '>':
                return "&#62;";
            case '&':
                return "&amp;";
            case '"':
                return "&#34;";
            case '\'':
                return "&#39;";
            case '\r':
                return "&#114;";
            case '\n':
                return "&#110;";
        }
        return null;
    }
    
    /**
     * 防止跨站脚本攻击
     * 过滤敏感字符
     * 将HTML特殊字符转换为相应的实体字符。
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filter(String value)
    {
        
        if (StringUtils.isBlank(value))
        {
            value = "";
        }
        
        return value;
    }
    
    /**
     * 对产品线和产品族中的实体码进行转码
     * 转码敏感字符
     * 将实体码转换为对应的特殊字符
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String reverseNaviItem(String value)
    {
        
        if (value == null || value.length() == 0)
        {
            return value;
        }
        try
        {
            
            value = value.replaceAll("&#40;", "(");
            value = value.replaceAll("&#41;", ")");
            value = value.replaceAll("&#60;", "<");
            value = value.replaceAll("&#62;", ">");
            value = value.replaceAll("&amp;", "&");
            value = value.replaceAll("&#34;", "\"");
            value = value.replaceAll("&#39;", "\'");
        }
        catch (Exception e)
        {
            LOG.error("reverseNaviItem error!");
        }
        return value;
    }
    
    /**
     * 针对shell脚本进行转义
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static boolean filterShell(String shell)
    {
        // shell 腳本 . 分割開
        String notShell = "|.;.&.$.&&.||.>.>>.<";
        
        // 若是null 或者 “ ” ，直接返回
        if (StringUtils.isBlank(shell))
        {
            return true;
        }
        String lowerValue = shell.toLowerCase();
        String[] arrKeyword = StringUtils.split(notShell, ".");
        if (arrKeyword != null)
        {
            for (String keyword : arrKeyword)
            {
                if (lowerValue.indexOf(keyword) >= 0)
                {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * 对标题的双引号及'/'进行转义
     * 
     * 
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filterTitle(String value)
    {
        if (value == null || value.length() == 0)
        {
            return value;
        }
        
        return value.replace("\"", "\\");
    }
    
    /**
     * 对标题的双引号进行实体码转义
     * 
     * 
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filterQuotation(String value)
    {
        if (value == null || value.length() == 0)
        {
            return value;
        }
        value = value.replaceAll("\"", "&#34;");
        return value;
    }
    
    /**
     * 防止SQL注入
     * 验证字符类型不能包含特殊字符
     * 检测单引号和一些SQL关键字
     *
     * @param string
     * @return
     */
    public static boolean checkNonlicetCharacters(String string)
    {
        boolean flag = false;
        //过滤关键字-*
        
        String lowerCase = string.toLowerCase();
        
        //		for (int i = 0; i < KEYWORDS.length; i++) { 
        if (lowerCase.indexOf("'") >= 0)
        {
            flag = true;
        }
        
        //		} 
        return flag;
    }
    
    public static boolean checkNonlicetCharacters(String[] strArray)
    {
        boolean flag = false;
        for (int i = 0, j = strArray.length; i < j; i++)
        {
            //过滤关键字
            String strPar = strArray[i];
            // 不许出现单引号"(", "%", "/*", "*/",
            
            if (null != strPar)
            {
                if (strPar.indexOf("'") >= 0)
                {
                    flag = true;
                }
            }
            
        }
        
        return flag;
    }
    
    /**
     * 判断传入参数是否包含SQL注入攻击、跨站脚本和HTML攻击
     * 
     * @param numStr 待校验的字符串
     * @return
     */
    public static boolean injectFilter(String str)
    {
        //字符串讲判空处理
        if (StringUtils.isBlank(str))
        {
            return true;
        }
        //字符串的标准化
        str = Normalizer.normalize(str, Form.NFKC);
        boolean isPass = injectFilterCommon(str);
        if (isPass)
        {
            //转码后再次校验
            try
            {
                String switchStr = URLDecoder.decode(str, "UTF-8");
                isPass = injectFilterCommon(switchStr);
            }
            catch (UnsupportedEncodingException e)
            {
                CodeCCUtils.errorLog(LOG, "SecurityFilter SQLFilter decode error:UnsupportedEncodingException. str:"
                        + str, e);
            }
            catch (IllegalArgumentException e)
            {
                CodeCCUtils.errorLog(LOG, "SecurityFilter SQLFilter decode IllegalArgumentException. str:" + str, e);
            }
        }
        return isPass;
    }
    
    /**
     * 检查字符串注入
     * <一句话功能简述>
     * <功能详细描述>
     * @param str
     * @return [参数说明]
     *
     * @return boolean [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    private static boolean injectFilterCommon(String str)
    {
        if (str.contains("'") || str.contains("(") || str.contains(")"))
        {
            String inject = "and|or|exec|insert|select|delete|update|count|chr|mid|master|truncate|char|declare|--|drop|\\+";
            Pattern injectPattern = Pattern.compile(inject, Pattern.CASE_INSENSITIVE);
            if (injectPattern.matcher(str).find())
            {
                LOG.error("injectFilter find sql inject:" + str);
                return false;
            }
        }
        else if (str.contains("<"))
        {
            String inject = "(script)|on(mouseover|mouseon|mouseout|click|dblclick|blur|focus|change)|url|\t";
            Pattern injectPattern = Pattern.compile(inject, Pattern.CASE_INSENSITIVE);
            if (injectPattern.matcher(str).find())
            {
                LOG.error("injectFilter find script inject:" + str);
                return false;
            }
        }
        return true;
    }
    
    /**
     * 防止SQL注入
     * 将拼接SQL参数中的单个单引号替换成两个单引号，仅用于动态拼接SQL且使用Statement的情况
     * 使用PreparedStatement时不需要调用此方法
     *
     *
     * @param string
     * @return
     */
    public static String getValidSQLPara(String string)
    {
        if (string == null || string.length() == 0)
        {
            return string;
        }
        return string.replaceAll("'", "''");
    }
    
    /**
     * 对标题的/进行转义\/
     * 
     * 
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filterBias(String value)
    {
        if (value == null || value.length() == 0)
        {
            return value;
        }
        
        return value.replace("/", "\\/");
    }
    
    /**
     * 防止跨站脚本攻击
     * 过滤敏感字符
     * 将HTML特殊字符转换为相应的实体字符。
     * Filter the specified string for characters that are sensitive to
     * HTML interpreters, returning the string with these characters replaced
     * by the corresponding character entities.
     *
     * @param value The string to be filtered and returned
     */
    public static String filterJson(String value)
    {
        
        if (value == null || value.length() == 0)
        {
            return value;
        }
        
        StringBuffer resultString = null;
        String filtered = null;
        for (int i = 0; i < value.length(); i++)
        {
            filtered = null;
            switch (value.charAt(i))
            {
                case '<':
                    filtered = "&#60;";
                    break;
                case '>':
                    filtered = "&#62;";
                    break;
                case '&':
                    filtered = "&amp;";
                    break;
                case '\'':
                    filtered = "&#39;";
                    break;
                case '(':
                    filtered = "&#40;";
                    break;
                case ')':
                    filtered = "&#41;";
                    break;
            }
            
            if (resultString == null)
            {
                if (filtered != null)
                {
                    resultString = new StringBuffer(value.length() + 50);
                    if (i > 0)
                    {
                        resultString.append(value.substring(0, i));
                    }
                    resultString.append(filtered);
                }
            }
            else
            {
                if (filtered == null)
                {
                    resultString.append(value.charAt(i));
                }
                else
                {
                    resultString.append(filtered);
                }
            }
        }
        
        return resultString == null ? value : resultString.toString();
    }
    
    public static String subString(String value, int length)
    {
        
        String retstr = "";
        if (value == null || value.equals(""))
        {
            return retstr;
        }
        
        String chinese = "[u0391-uFFE5]";
        int valueLength = 0;
        int str_len = value.length();
        
        for (int i = 0; i < str_len; i++)
        {
            /* 获取一个字符 */
            String temp = value.substring(i, i + 1);
            /* 判断是否为中文字符 */
            valueLength++;
            if (!temp.matches(chinese))
            {
                valueLength++;
            }
            if (valueLength > length)
            {
                retstr = retstr.concat("...");
                return retstr;
            }
            retstr = retstr.concat(temp);
        }
        return retstr;
    }
    
    /**
     * 
     * Normalizer.normalize(input, Form.NFKC)函数在字符串很长时，有性能问题
     * 在此做一个限制，对于超长字符串不进行normalize
     * 
     * @param input
     * @return
     * @see [类、类#方法、类#成员]
     */
    public static String normalize(String input)
    {
        if (StringUtils.isBlank(input) || StringUtils.length(input) > 1000)
        {
            return input;
        }
        
        return Normalizer.normalize(input, Form.NFKC);
    }
    
    /**
     * clear FORTIFY.Trust_Boundary_Violation
     * @param message
     * @return
     * @see [类、类#方法、类#成员]
     */
    public static String clearTrustViolation(String message)
    {
        if (StringUtils.isBlank(message))
        {
            return message;
        }
        
        String clean = StringEscapeUtils.escapeHtml4(message);
        
        return clean;
    }
}
-----------LanguageFilter---分隔线
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang3.StringUtils;

public class LanguageFilter implements Filter
{

    private static final List<String> languages = new ArrayList<String>();
    private static final String LANG_KEY = "lang";
    private static final String LANG_KEY_NLS = "nls";
    private static final String LANG_ZH = "zh";
    private static final String LANG_EN = "en";
    private static final String LANG_DEFAULT = LANG_ZH;
    private static int zhIndex;
    
    /**
     * Ajax异步请求HttpHeader的Key
     */
    private static final String AJAX_HTTP_REQUEST_KEY = "X-Requested-With";
    
    /**
     * Ajax异步请求HttpHeader的Value
     */
    private static final String AJAX_HTTP_REQUEST_VALUE = "XMLHttpRequest";
    
    public void init(FilterConfig filterConfig)
        throws ServletException
    {
        String[] langs = new String[]{"en", "EN", "en_US", "en_us", "zh", "ZH", "zh_CN", "zh_cn"};
        languages.addAll(Arrays.asList(langs));
        zhIndex = languages.indexOf(LANG_ZH);
    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException
    {
        
        HttpServletResponse httpRep = (HttpServletResponse)response;
        HttpServletRequest httpReq = (HttpServletRequest)request;
        chain.doFilter(request, response);
        if(isDocumentRequest(httpReq))
        {
            String lang = getLangFromCookie(httpReq);
            if(StringUtils.isEmpty(lang))
            {
                lang = getLangFromSession(httpReq);
                if(StringUtils.isEmpty(lang))
                {
                    lang = getLangFromLocale(httpReq);
                    if(StringUtils.isEmpty(lang))
                    {
                        lang = LANG_DEFAULT;
                    }
                    setLanguageToSession(lang, httpReq);
                }
                setLanguageToCookie(lang, httpRep);
            }
        }
    }
    
    boolean isDocumentRequest(HttpServletRequest req)
    {
        String pathInfo = req.getPathInfo();
        boolean isResource = isEndWith(pathInfo, ".js", ".css");
        boolean isImage = isEndWith(pathInfo, ".jpg", ".png", ".gif", ".jpeg", ".bmp");
        boolean isAjax = AJAX_HTTP_REQUEST_VALUE.equals(req.getHeader(AJAX_HTTP_REQUEST_KEY));
        
        return !(isAjax || isImage || isResource);
       
    }
    /**
     * 
     * @param str
     * @param args
     * @return
     */
    boolean isEndWith(String string, String... args)
    {
        if(args == null)
        {
            return false;
        }
        for(int i = 0; i < args.length; i++)
        {
            if(StringUtils.endsWithIgnoreCase(string, args[i]))
            {
                return true;
            }
        }
        return false;
    }
    
    String getLangFromLocale(HttpServletRequest req)
    {
        Locale locale = req.getLocale();
        if(locale != null)
        {
            return getValidateLang(locale.getLanguage());
        }
        return null;
    }
    
    String getLangFromSession(HttpServletRequest req)
    {
        String lang;
        lang = getValidateLang(req.getSession().getAttribute(LANG_KEY));
        if(!StringUtils.isEmpty(lang))
        {
            return lang;
        }
        lang = getValidateLang(req.getSession().getAttribute(LANG_KEY.toUpperCase()));
        if(!StringUtils.isEmpty(lang))
        {
            return lang;
        }
        lang = getValidateLang(req.getSession().getAttribute(LANG_KEY_NLS));
        if(!StringUtils.isEmpty(lang))
        {
            return lang;
        }
        lang = getValidateLang(req.getSession().getAttribute(LANG_KEY_NLS.toUpperCase()));
        if(!StringUtils.isEmpty(lang))
        {
            return lang;
        }
        return null;
    }
    
    String getLangFromCookie(HttpServletRequest req)
    {
        String lang = null;
        Cookie[] cookies = req.getCookies();
        if(cookies != null)
        {
            for(Cookie cookie : cookies)
            {
                if(LANG_KEY.equalsIgnoreCase(cookie.getName()))
                {
                    lang = cookie.getValue();
                    break;
                }
            }
        }
        return getValidateLang(lang);
    }
    
    String getValidateLang(Object langObj)
    {
        if(langObj == null)
        {
            return null;
        }
        String lang = langObj.toString();
        if(StringUtils.isEmpty(lang))
        {
            return null;
        }
        int index = languages.indexOf(lang);
        if(index > -1)
        {
            return (index >= zhIndex) ? LANG_ZH : LANG_EN;
        }
        return null;
    }
    
    void setLanguageToCookie(String lang, HttpServletResponse httpRep)
    {
        Cookie cookie = new Cookie(LANG_KEY, lang);
        cookie.setPath("/");
        cookie.setMaxAge(-1);
        cookie.setSecure(true);
        httpRep.addCookie(cookie);
    }
    
    void setLanguageToSession(String lang, HttpServletRequest httpReq)
    {
        httpReq.getSession().setAttribute(LANG_KEY, lang);
    }

    public void destroy()
    {
        languages.clear();
    }
    
}

